<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Twitch Subathon Overlay</title>

<!-- Diablo / Exocet-like font -->
<style>
  @font-face {
    font-family: 'Exocet';
    src: url('http://spaan.ca/exocet.ttf') format('truetype'),
    font-display: swap;
  }

  body {
    margin: 0;
    background: transparent;
    color: #ffd37f;
    font-family: 'Exocet', 'Trebuchet MS', sans-serif;
    text-align: center;
    font-size: 54px;
    font-weight: bold;
    letter-spacing: 2px;
    text-shadow:
      0 0 10px #ffbb00,
      0 0 20px #ff6600,
      0 0 30px #ff3300;
  }

  #counter {
    margin-top: 40px;
    animation: fadeIn 0.8s ease-in-out;
  }

  @keyframes pop {
    0% { transform: scale(1); text-shadow: 0 0 15px #ffbb00, 0 0 25px #ff3300; }
    50% { transform: scale(1.15); text-shadow: 0 0 25px #fff1b8, 0 0 40px #ff6600; }
    100% { transform: scale(1); text-shadow: 0 0 10px #ffbb00, 0 0 20px #ff3300; }
  }

  #login {
    background-color: #9146FF;
    color: white;
    border: none;
    padding: 16px 32px;
    border-radius: 10px;
    font-size: 24px;
    cursor: pointer;
    margin-top: 100px;
  }
</style>
</head>
<body>
  <button id="login">Authorize with Twitch</button>
  <div id="counter" style="display:none;">Subs Today: 0 (Trav Runs: 0)</div>

  <script>
    // === CONFIGURATION ===
    const CLIENT_ID = "2escgq91m5o4qli9fnhao7gmhrq0ho";
    const REDIRECT_URI = window.location.origin + window.location.pathname;
    const SCOPES = "channel:read:subscriptions user:read:email";
    // ======================

    let accessToken = null;
    let broadcasterId = null;
    let subsToday = 0;

    const loginButton = document.getElementById("login");
    const counterDiv = document.getElementById("counter");

    // === LOCAL PERSISTENCE ===
    function saveState() {
      const state = { subsToday };
      localStorage.setItem("subathonState", JSON.stringify(state));
    }

    function loadState() {
      const data = localStorage.getItem("subathonState");
      if (data) {
        try {
          const state = JSON.parse(data);
          subsToday = state.subsToday || 0;
        } catch (e) {
          console.error("Error loading saved state:", e);
        }
      }
    }

    function saveToken() {
      if (accessToken) localStorage.setItem("twitchAccessToken", accessToken);
    }

    function loadToken() {
      const token = localStorage.getItem("twitchAccessToken");
      if (token) {
        accessToken = token;
        console.log("Loaded saved Twitch access token.");
      }
    }

    // === AUTH FLOW ===
    function authorize() {
      const url = `https://id.twitch.tv/oauth2/authorize?client_id=${CLIENT_ID}&redirect_uri=${encodeURIComponent(REDIRECT_URI)}&response_type=token&scope=${encodeURIComponent(SCOPES)}`;
      window.location = url;
    }

    function parseToken() {
      const hash = window.location.hash;
      if (hash && hash.includes("access_token")) {
        const params = new URLSearchParams(hash.substring(1));
        accessToken = params.get("access_token");
        console.log("Received new Twitch access token.");
        saveToken();
        window.history.replaceState({}, document.title, window.location.pathname);
      }
    }

    async function fetchUser() {
      const res = await fetch("https://api.twitch.tv/helix/users", {
        headers: {
          "Authorization": `Bearer ${accessToken}`,
          "Client-ID": CLIENT_ID
        }
      });
      const data = await res.json();

      if (!data.data || !data.data.length) {
        console.error("Failed to fetch user info:", data);
        return false;
      }

      broadcasterId = data.data[0].id;
      console.log("Logged in as:", data.data[0].display_name);
      return true;
    }

    function updateDisplay() {
      const runs = subsToday * 10;
      counterDiv.textContent = `Subs Today: ${subsToday} (Trav Runs: ${runs})`;
      counterDiv.style.animation = "pop 0.5s ease";
      setTimeout(() => (counterDiv.style.animation = ""), 600);
    }

    function connectEventSub() {
      const ws = new WebSocket("wss://eventsub.wss.twitch.tv/ws");
      ws.onopen = () => console.log("Connected to EventSub WebSocket");

      ws.onmessage = async (event) => {
        const msg = JSON.parse(event.data);

        if (msg.metadata?.message_type === "session_welcome") {
          const sessionId = msg.payload.session.id;
          subscribeToEvents(sessionId);
        }

        if (msg.metadata?.message_type === "notification") {
          const type = msg.metadata.subscription_type;
          const e = msg.payload.event;

          if (type === "channel.subscribe" || type === "channel.subscription.message") {
            subsToday += 1;
          } else if (type === "channel.subscription.gift") {
            subsToday += e.total ?? 1;
          }

          updateDisplay();
          saveState();
        }
      };

      ws.onclose = () => {
        console.warn("EventSub disconnected. Reconnecting in 10s...");
        setTimeout(connectEventSub, 10000);
      };
    }

    async function subscribeToEvents(sessionId) {
      const topics = [
        "channel.subscribe",
        "channel.subscription.message",
        "channel.subscription.gift"
      ];

      for (const type of topics) {
        const res = await fetch("https://api.twitch.tv/helix/eventsub/subscriptions", {
          method: "POST",
          headers: {
            "Client-ID": CLIENT_ID,
            "Authorization": `Bearer ${accessToken}`,
            "Content-Type": "application/json"
          },
          body: JSON.stringify({
            type,
            version: "1",
            condition: { broadcaster_user_id: broadcasterId },
            transport: { method: "websocket", session_id: sessionId }
          })
        });

        const data = await res.json();
        if (data.error) console.error("EventSub subscribe error:", data);
      }

      console.log("Subscribed to Twitch sub events.");
    }

    async function startOverlay() {
      loginButton.style.display = "none";
      counterDiv.style.display = "block";
      loadState();
      const ok = await fetchUser();
      if (!ok) {
        console.error("User fetch failed â€” invalid token?");
        localStorage.removeItem("twitchAccessToken");
        window.location.reload();
        return;
      }
      updateDisplay();
      connectEventSub();
    }

    function manualReset() {
      subsToday = 0;
      saveState();
      updateDisplay();
      console.log("Manual counter reset.");
    }

    if (window.location.search.includes("reset=true")) {
      localStorage.removeItem("subathonState");
      manualReset();
    }
    document.addEventListener("keydown", e => {
      if (e.key.toLowerCase() === "r") manualReset();
    });

    // === INIT ===
    parseToken();
    loadToken();
    if (accessToken) startOverlay();
    else {
      loginButton.style.display = "block";
      counterDiv.style.display = "none";
      loginButton.onclick = authorize;
    }
  </script>
</body>
</html>

